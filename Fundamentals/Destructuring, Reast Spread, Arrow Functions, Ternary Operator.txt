

Rest/Spread 

    ES6  provides us with a new operator, ..., that is context depenedent. Its purpouse is to capture the rest of a data set or to spread content of an existing structure 

    Destructuring

        Now that we understand usuing rest and spread, we can work it into our destructuring. Remembering our array example from the destructuring chapter we wanted to extract the first couple animals from our list. 

            const animals = ['horse', 'dog', 'fish', 'cat', 'bird'];
            const [firstAnimal, secondAnimal] = animals;

        If we want the remaning animals, we use a rest pattern at the end of the assignment. 

            const [firstAnimal, secondAnimal, ...otherAnimals] = animals;
            otherAnimals
            // => ['fish', 'cat', 'bird']

    Objects 

        Can we do the same with objects? Yes, While object spread came about a few years after ES6 it esems like a good idea to examine it here. 

            const person = {
            firstName: 'Bob',
            lastName: 'Marley',
            email: 'bob@marley.com',
            password: 'sekureP@ssw0rd9',
            username: 'barley',
            addresses: [
                {
                address: '1600 Pennsylvania Avenue',
                city: 'Washington, D.C.',
                zipcode: '20500',
                },
                {
                address: '221B Baker St.',
                city: 'London',
                zipcode: 'WC2N 5DU',
                }
            ],
            createdAt: 1543945177623
            };

        Grabbing firstName and lastName from person is easy, along with assigning all other properties to a "catchall" 

            const { firstName, lastName, ...attributes } = person;

        Usuing spread we can quickly make complete copies of objects or arrays. 

            const personCopy = { ...person };

        There are some limitations, the copy is shallow, so any complex or nested structures with objects refrences will still point to the same object. As they are the same place in memory. 

            const personCopy = { ...person };
            personCopy === person
            // => false
            personCopy.addresses === person.addresses
            // => true


Arrow Functions 

    Understanding and utilizing anonymous functions is important to becoming a skilled JS dev. An anonymous function is simply a function without a name, ES6 introduces a new shortened syntax for writing anonymous functions. That is the focus of this chapter. 

    Function Keyword 

        Consider this sayHello function assigned to a variable. 

            var sayHello = function(name) {
            console.log('Hello ' + name);
            };

        Utilizing ES6 arrow functions, colloquially fat arrow functions, we can rewrite this function as such 

            const sayHello = (name) => {
            console.log(`Hello ${name}`);
            };

        Notice that we have omitted the function keyword and now have an arrow => pointing to the function body. Intresting but why other than less typing? 

        For simple methods we can refine the example further. Single parameters don't need parentheses and with the function body being a single statement we an remove the curly braces 

            const sayHello = name => console.log(`hello ${name}`); 

        Concise. more complex functions will need a more comleete body ({}) and multiple parameters will require parentheses, Another benefit of utilizing arrow functions for simple expression is implicit returns. 

            var square = function(n) {
            return n * n;
            };

        Will become 

            const square = n => n * n;

        Traditional functions require explicit returns, such as in the first square, with arrow functions the result of our expression n * n is implicitly returned to the caller. 

        Arrow functions give us the ability to shorten the syntax of the retuning object as well. However there is one piece of syntax we need to return an object. Lets look at the example below. 

            // longhand notation to return an object
            // NOTE: first set of brackets are defining the function body
            // and the second set of brackets are to create the object literal
            const returnObjLonghand = () => {
                return { 
                    firstName: 'John',
                    lastName: 'Wick'
                }
            }
            /**
            * The example below wouldn't work because the 
            * brackets are interpreted as opening the body of the 
            * function rather than brackets to create an object literal 
            */
            const returnObj = () => { firstName: 'John', lastName: 'Wick' }
            // surrounding the implicit return with parentheses solves the problem
            const returnObjFixed = () => ({ firstName: 'John', lastName: 'Wick' });


        Context 

            Fancy Sytax isn't the only change with arrow functions. They also inherit context from the parent scope. To demostrate this let's create a card Deck class. 

                class Deck {
                    constructor() {
                        const suits = ['Diamond', 'Heart', 'Spade', 'Club'];
                        const faces = ['Ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King'];
                        const deck = [];
                        for (const suit of suits) {
                        for (const face of faces) {
                            deck.push(this.createCard(suit, face));
                        }
                        }
                        this.deck = deck;
                    }
                    createCard(suit, face) {
                        return face + " of " + suit;
                    }
                }

            We'll start refactoring for a more functional approach using forEach, but continue usuing traditional anonymous functions. 

                class Deck {
                    constructor() {
                        const suits = ['Diamond', 'Heart', 'Spade', 'Club'];
                        const faces = ['Ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King'];
                        const deck = [];
                        suits.forEach(function(suit) {
                        faces.forEach(function(face) {
                            deck.push(this.createCard(suit, face));
                        });
                        });
                        this.deck = deck;
                    }
                    createCard(suit, face) {
                        return face + " of " + suit;
                    }
                }

            Creating a deck will now result in a TypeError cannot read property createCard of undefined because this. in our anonymouse function doesn't have the same context as our loops. 

                class Deck {
                    constructor() {
                        const suits = ['Diamond', 'Heart', 'Spade', 'Club'];
                        const faces = ['Ace', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'Jack', 'Queen', 'King'];
                        const deck = [];
                        suits.forEach(suit => {
                        faces.forEach(face => {
                            deck.push(this.createCard(suit, face));
                        });
                        });
                        this.deck = deck;
                    }
                    createCard(suit, face) {
                        return face + " of " + suit;
                    }
                    }

            Arrow functions don't create their own context, it looks to the enclsing scope for that information. Therefore this should now refer to the Deck instance, which has a create card method.

        Conclusion 

            Arrow functions provide a simpler syntax with implicit returns for succinct expressions. Additionaly they inherit context from parent scopes. While this is great much of the time, there are instances when you want context to change so be aware of how an arrow function might affect your code. 




